$date
	Sat Dec  8 18:57:05 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$scope module PE $end
$var wire 1 ! clk $end
$var wire 1 " pendfpu $end
$var wire 1 # pendpc $end
$var wire 1 $ pendz $end
$var wire 1 % reset $end
$var wire 16 & fpu_result [15:0] $end
$var wire 1 ' fpu_done $end
$var reg 1 ( fpu_en $end
$var reg 1 ) halt $end
$var reg 1 * havepre $end
$var reg 16 + im0 [15:0] $end
$var reg 16 , ir [15:0] $end
$var reg 16 - ir0 [15:0] $end
$var reg 16 . ir1 [15:0] $end
$var reg 1 / jump $end
$var reg 16 0 pc [15:0] $end
$var reg 16 1 pc0 [15:0] $end
$var reg 12 2 prefix [11:0] $end
$var reg 16 3 rd1 [15:0] $end
$var reg 16 4 res [15:0] $end
$var reg 16 5 rn1 [15:0] $end
$var reg 16 6 target [15:0] $end
$var reg 16 7 tpc [15:0] $end
$var reg 1 8 wait1 $end
$var reg 1 9 zreg $end
$scope function iscond $end
$var reg 16 : inst [15:0] $end
$var reg 1 ; iscond $end
$upscope $end
$scope function setspc $end
$var reg 16 < inst [15:0] $end
$var reg 1 = setspc $end
$upscope $end
$scope function setsrd $end
$var reg 16 > inst [15:0] $end
$var reg 1 ? setsrd $end
$upscope $end
$scope function setsz $end
$var reg 16 @ inst [15:0] $end
$var reg 1 A setsz $end
$upscope $end
$scope function usesim $end
$var reg 16 B inst [15:0] $end
$var reg 1 C usesim $end
$upscope $end
$scope function usesrd $end
$var reg 16 D inst [15:0] $end
$var reg 1 E usesrd $end
$upscope $end
$scope function usesrn $end
$var reg 16 F inst [15:0] $end
$var reg 1 G usesrn $end
$upscope $end
$scope module myfpu $end
$var wire 1 ! clk $end
$var wire 1 ( en $end
$var wire 5 H instr [4:0] $end
$var wire 16 I op1 [15:0] $end
$var wire 16 J op2 [15:0] $end
$var wire 8 K srl_out [7:0] $end
$var wire 5 L d_tmp [4:0] $end
$var wire 5 M d [4:0] $end
$var reg 1 ' done $end
$var reg 8 N exp [7:0] $end
$var reg 8 O exp_p1 [7:0] $end
$var reg 7 P frac [6:0] $end
$var reg 16 Q int [15:0] $end
$var reg 16 R larger [15:0] $end
$var reg 16 S result [15:0] $end
$var reg 8 T shift [7:0] $end
$var reg 1 U sign $end
$var reg 16 V smaller [15:0] $end
$var integer 32 W state [31:0] $end
$var integer 32 X tmp [31:0] $end
$scope module lead0 $end
$var wire 16 Y s [15:0] $end
$var reg 5 Z d [4:0] $end
$var reg 2 [ s2 [1:0] $end
$var reg 4 \ s4 [3:0] $end
$var reg 8 ] s8 [7:0] $end
$upscope $end
$scope module lead1 $end
$var wire 16 ^ s [15:0] $end
$var reg 5 _ d [4:0] $end
$var reg 2 ` s2 [1:0] $end
$var reg 4 a s4 [3:0] $end
$var reg 8 b s8 [7:0] $end
$upscope $end
$scope module mysrl $end
$var wire 8 c shift [7:0] $end
$var wire 8 d src [7:0] $end
$var reg 8 e by1 [7:0] $end
$var reg 8 f by2 [7:0] $end
$var reg 8 g by4 [7:0] $end
$var reg 8 h dst [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module testbench $end
$scope module PE $end
$var reg 16 i \r[0] [15:0] $end
$upscope $end
$upscope $end
$scope module testbench $end
$scope module PE $end
$var reg 16 j \r[1] [15:0] $end
$upscope $end
$upscope $end
$scope module testbench $end
$scope module PE $end
$var reg 16 k \r[2] [15:0] $end
$upscope $end
$upscope $end
$scope module testbench $end
$scope module PE $end
$var reg 16 l \r[3] [15:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
b1xxxxxxx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
b110010 W
bx V
xU
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
b0 H
xG
bx F
xE
bx D
xC
bx B
0A
b0 @
0?
b0 >
0=
b0 <
x;
bx :
x9
x8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
b0 0
0/
b0 .
b0 -
bx ,
bx +
0*
0)
x(
0'
bx &
0%
0$
0#
x"
0!
$end
#10
1%
#20
0%
#30
x$
x#
xA
bx @
x=
x?
bx >
bx <
b0 1
b1 0
bx -
b0 7
xC
bx B
08
1G
b0 F
0E
b0 D
1!
#40
0!
#50
bx H
bx .
b1 1
b10 0
xG
bx F
xE
bx D
x?
bx >
b1 7
1!
#60
0!
#70
b10 1
b11 0
1)
b10 7
1!
#80
0!
