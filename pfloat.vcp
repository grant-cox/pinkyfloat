$date
	Fri Dec  7 18:48:39 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$var wire 16 ! result [15:0] $end
$var wire 1 " done $end
$var reg 1 # clk $end
$var reg 1 $ en $end
$var reg 5 % instr [4:0] $end
$var reg 16 & rd [15:0] $end
$var reg 16 ' rn [15:0] $end
$var integer 32 ( counter [31:0] $end
$scope module myfpu $end
$var wire 1 # clk $end
$var wire 1 $ en $end
$var wire 5 ) instr [4:0] $end
$var wire 16 * op1 [15:0] $end
$var wire 16 + op2 [15:0] $end
$var wire 8 , srl_out [7:0] $end
$var wire 5 - d [4:0] $end
$var reg 1 " done $end
$var reg 8 . exp [7:0] $end
$var reg 8 / exp_p1 [7:0] $end
$var reg 7 0 frac [6:0] $end
$var reg 8 1 frac_w1 [7:0] $end
$var reg 16 2 int [15:0] $end
$var reg 16 3 larger [15:0] $end
$var reg 1 4 overflow $end
$var reg 16 5 result [15:0] $end
$var reg 8 6 shift [7:0] $end
$var reg 1 7 sign $end
$var reg 16 8 smaller [15:0] $end
$var integer 32 9 state [31:0] $end
$var integer 32 : tmp [31:0] $end
$scope module lead0 $end
$var wire 16 ; s [15:0] $end
$var reg 5 < d [4:0] $end
$var reg 2 = s2 [1:0] $end
$var reg 4 > s4 [3:0] $end
$var reg 8 ? s8 [7:0] $end
$upscope $end
$scope module mysrl $end
$var wire 8 @ shift [7:0] $end
$var wire 8 A src [7:0] $end
$var reg 8 B by1 [7:0] $end
$var reg 8 C by2 [7:0] $end
$var reg 8 D by4 [7:0] $end
$var reg 8 E dst [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
b110010 9
bx 8
x7
bx 6
bx 5
x4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
b11101111111111 +
b100100011000011 *
b10101 )
b0 (
b11101111111111 '
b100100011000011 &
b10101 %
x$
0#
0"
bx !
$end
#4
1$
#9
b110111 9
b0 0
b10000110 .
07
1#
#14
b1 (
0#
#19
1"
b100001100000000 !
b100001100000000 5
1#
#24
b10 (
0#
#29
1#
#34
b11 (
0#
#39
1#
#44
b100 (
0#
#49
1#
#54
b101 (
0#
